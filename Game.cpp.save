#include "include.h"

const int SizeY = 22;  // SizeField [Pixels] / SizeTile
const int SizeX = 12;  // SizeField [Pixels] / SizeTile
const int SizeTile = 45;
const int WField = 27; //[Pixels]

struct aKeyBoardControl
    {
    int left, up, right, down;
    };

struct Point
    {
    int x, y;
    };

struct RunGamePar
    {
    HDC tiles;
    HDC background;
    bool cheatMode;
    Point position;
    aKeyBoardControl Player;
    volatile int score;
    };

void keyBoardControl (int Field[SizeY][SizeX], const aKeyBoardControl theControl, Point posOfFigur[]);
bool checkBorder (int Field[SizeY][SizeX], Point posOfFigur []);
void RotateFigure (int Field[SizeY][SizeX], Point posOfFigur []);
void StepPlayGame (int Field[SizeY][SizeX], bool cheatMode, int* ColorNum, int* NumBrick, int* newColorNum, int* newNumBrick, Point posOfFigur[]);
void CheakIsLineReady (int Field[SizeY][SizeX], int* NLines);
void RunGame (void* game);
void CreatNewFigure (bool cheatMode, int* NumBrick,  int* newNumBrick, int* newColorNum, Point posOfFigur[]);
void copyArray (Point oldArr [], Point newArr [], int lenArr);

void PrintScore (int NLines, HDC dc);
void PrintTime (int timer, HDC dc);
void PrintNextFigur (HDC tiles, int newNumBrick, int newColorNum, Point position, HDC dc);
void DrawField (int Field[SizeY][SizeX], HDC tiles, HDC background, int ColorNum, Point posOfFigur[], Point position, HDC dc);

int RunLevels (bool cheatMode);
int Level1 (bool cheatMode);
int Level2 (bool cheatMode);

const int Figures[7][4] =
    {
    {1, 3, 5, 7}, // I  0
    {2, 4, 5, 7}, // Z  1
    {3, 5, 4, 6}, // S  2
    {3, 5, 4, 7}, // T  3
    {2, 3, 5, 7}, // L  4
    {3, 5, 7, 6}, // J  5
    {2, 3, 4, 5}  // O  6
    };


//====================================================
void RunGame (void* game)
    {
    HDC              tiles      =  Resourses[tiles].pic;
    HDC              background =  Resourses[Tetris].pic;
    bool             cheatMode  =  cheatMode;
    Point            position   =  {0, 0};
    aKeyBoardControl Player     =  {'A', 'W', 'D', 'S'};
    volatile int    Score       = -1;

    HDC dc = txCreateCompatibleDC (WndSz.x, WndSz.y);

    int Field[SizeY][SizeX] = {0};

    int newNumBrick = rand() % 6;
    int NumBrick = rand() % 6;

    int newColorNum = 1 + rand() % 7;
    int ColorNum = 1 + rand() % 7;

    int NLines = 0;

    int timer = GetTickCount ();

    Point posOfFigur[4] = {};
    txBegin ();

    CreatNewFigure (cheatMode, &NumBrick, &newNumBrick, &newColorNum, posOfFigur);

    txPlaySound ("music.wav", SND_LOOP);


    while (checkBorder(Field, posOfFigur))
        {

        StepPlayGame(Field, cheatMode, &ColorNum, &NumBrick, &newColorNum, &newNumBrick, posOfFigur);

        keyBoardControl (Field, Player, posOfFigur);

        CheakIsLineReady (Field, &NLines);

        EnterCriticalSection (&LockDesktop);
            DrawField (Field, tiles, background, ColorNum, posOfFigur, position, dc);
            PrintScore (NLines, dc);
            PrintTime (timer, dc);
            PrintNextFigur (tiles, newNumBrick, newColorNum, position, dc);
        LeaveCriticalSection (&LockDesktop);

        txSleep (100);
        }

    PrintTime(timer, dc);
    txPlaySound (NULL);

    *Score = NLines * 10;
    }

//====================================================

void PrintNextFigur (HDC tiles, int newNumBrick, int newColorNum, Point position, HDC dc)
    {
    Point posOfFigur[4] = {};

    for (int i = 0; i < 4; i++)
        {
        posOfFigur[i].x = Figures[newNumBrick][i] % 2 + SizeX / 2;

        posOfFigur[i].y = Figures[newNumBrick][i] / 2;
        }

    for (int i = 0; i < 4; i++)
        {
        txBitBlt (dc, posOfFigur [i].x * 35 + WField + position.x + 420, posOfFigur [i].y * 35 + position.y + 93, SizeTile, SizeTile, tiles, newColorNum * SizeTile, 0);
        }
    }

//====================================================

void PrintTime (int timer, HDC dc)
    {
    timer = (GetTickCount () - timer) / 1000;

    char textOfTime [50] = "";
    unsigned n = sprintf (textOfTime, "%i:%02i", timer/60, timer%60);
    assert (n < sizeof (textOfTime) - 1);

    txSetColor (TX_BLACK, 1);
    txSelectFont ("Impact", 100, -1, FW_DONTCARE, false, false, false, 0, dc);
    txDrawText (621, 824, 799, 979, textOfTime, DT_CENTER|DT_VCENTER|DT_WORDBREAK|DT_WORD_ELLIPSIS, dc);
    }

//====================================================

void PrintScore (int NLines, HDC dc)
    {
    char lines [10] = "";
    sprintf (lines, "%i", NLines*10);

    txSetColor (TX_BLACK, 1, dc);
    txSelectFont ("Impact", 100, -1, FW_DONTCARE, false, false, false, 0, dc);
    txDrawText (621, 585, 799, 736, lines, DT_CENTER|DT_VCENTER|DT_WORDBREAK|DT_WORD_ELLIPSIS, dc);
    }

//====================================================

void CreatNewFigure (bool cheatMode, int* NumBrick, int* newNumBrick, int* newColorNum, Point posOfFigur[])
    {
    if (cheatMode) *NumBrick = 0;

    else *newNumBrick = rand() % 6;

    *newColorNum = 1 + rand() % 7;

    for (int i = 0; i < 4; i++)
        {
        posOfFigur[i].x = Figures[*NumBrick][i] % 2 + SizeX / 2;

        posOfFigur[i].y = Figures[*NumBrick][i] / 2;
        }
    }

//====================================================

void CheakIsLineReady (int Field[SizeY][SizeX], int* NLines)
    {
    int nLines = SizeY-1;

	for (int y = SizeY-1; y > 0; y--)
        {
		int count = 0;

		for (int x = 0; x < SizeX; x++)
            {
		    if (Field [y][x]) count++;
		    Field [nLines][x] = Field [y][x];
            }


		if (count < SizeX) nLines-- ;
		else (*NLines) ++;
        }
     }

//====================================================

void DrawField (int Field[SizeY][SizeX], HDC tiles, HDC background, int ColorNum, Point posOfFigur [], Point position, HDC dc)
    {
    //txBitBlt (dc, position.x, position.y, WndSz.x, WndSz.y, background);

    for (int y = 0; y < SizeY; y++)
        for (int x = 0; x < SizeX; x++)
            {
            if (Field[y][x] == 0) continue;

            txBitBlt (dc, x*SizeTile + WField + position.x, y*SizeTile + position.y, SizeTile, SizeTile, tiles, Field [y][x] * SizeTile, 0);
            }

    for (int i = 0; i < 4; i++)
        {
        txBitBlt (dc, posOfFigur [i].x * SizeTile + WField + position.x, posOfFigur [i].y * SizeTile + position.y, SizeTile, SizeTile, tiles, ColorNum * SizeTile, 0);
        }
    }

//====================================================

void StepPlayGame (int Field[SizeY][SizeX], bool cheatMode, int* ColorNum, int* NumBrick, int* newColorNum, int* newNumBrick, Point posOfFigur [])
    {
    Point oldPosOfFigur [4] = {0};

    copyArray (oldPosOfFigur, posOfFigur, 4);

    for (int i = 0; i < 4; i++)
        {
        posOfFigur [i].y += 1;
        }

    if (!checkBorder (Field, posOfFigur))
        {
        for (int i = 0; i < 4; i++) {Field [oldPosOfFigur[i].y][oldPosOfFigur[i].x] = *ColorNum;}

        *NumBrick = *newNumBrick;
        *ColorNum = *newColorNum;

        CreatNewFigure (cheatMode, NumBrick, newNumBrick, newColorNum, posOfFigur);
        }
    }

//====================================================

void keyBoardControl (int Field[SizeY][SizeX], const aKeyBoardControl theControl, Point posOfFigur[])
    {
    Point oldPosOfFigur [4] = {0};

    copyArray (oldPosOfFigur, posOfFigur, 4);

    int dx = 0;

    if (GetAsyncKeyState (theControl.right))
        dx = +1;

    if (GetAsyncKeyState (theControl.left))
        dx = -1;

    if (GetAsyncKeyState (theControl.up))
        {
        RotateFigure (Field, posOfFigur);
        txSleep (10);
        }

    for (int i = 0; i < 4; i++) { oldPosOfFigur [i] = posOfFigur [i]; posOfFigur [i].x += dx; }

    if (!checkBorder (Field, posOfFigur))
        for (int i = 0; i < 4; i++) posOfFigur [i] = oldPosOfFigur [i];
    }

//====================================================

bool checkBorder (int Field[SizeY][SizeX], Point posOfFigur[])
    {
    for (int i = 0; i < 4; i++)
        {
        if (posOfFigur [i].x < 0 || posOfFigur [i].x >= SizeX || posOfFigur [i].y >= SizeY) return false;

        else if (Field [posOfFigur [i].y] [posOfFigur [i].x]) return false;
        }

    return true;
    }

//====================================================

void RotateFigure (int Field[SizeY][SizeX], Point posOfFigur[])
    {
    Point oldPosOfFigur [4] = {0};

    copyArray (oldPosOfFigur, posOfFigur, 4);

    Point p = posOfFigur [1];

    for (int i = 0; i < 4; i++)
        {
        int x  = posOfFigur [i].y - p.y;
        int y  = posOfFigur [i].x - p.x;

        posOfFigur [i].x =    p.x -   x;
        posOfFigur [i].y =    p.y +   y;
        }

    if (!checkBorder (Field, posOfFigur)) for (int i = 0; i < 4; i++) posOfFigur [i] = oldPosOfFigur [i];
    }

//====================================================

void copyArray (Point oldArr [], Point newArr [], int lenArr)
    {
    for (int i = 0; i < lenArr; i++) {oldArr [i] = newArr [i];}
    }
